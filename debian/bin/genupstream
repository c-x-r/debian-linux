#!/usr/bin/env python3

import deb822
import os
import os.path
import re
import subprocess
import sys
import warnings

from subprocess import PIPE

from debian_linux.debian import VersionLinux


# XXX This doesn't deal with classes in [...], which Python's re module
# doesn't support
_glob_re = re.compile(r'''\? |       # ? converts to .
                          \* |       # * converts to [^/]*
                          \[         # [...] is complicated
                             !?      # inversion
                             ]?      # ] is literal at start
                             [^\]]*  # any other character is literal
                          \]''',
                      re.VERBOSE)


def glob_to_regex(glob):
    def replace(match):
        group = match.group(0)
        if group == '?':
            return r'.'
        elif group == '*':
            return r'[^/]*'
        else:
            assert group[0] == '[' and group[-1] == ']' and len(group) >= 3
            # \ is not special inside [] in globs, so escape it throughout.
            # Replace initial '!' with '^'
            group = group.replace('\\', '\\\\')
            return ('[' + (group[1] if group[1] != '!' else '^') +
                    group[2:-1] + ']')
    return re.compile(_glob_re.sub(replace, glob))


def read_tree(ref):
    with subprocess.Popen(['git', 'ls-tree', '--full-tree', '-z', ref],
                           stdout=PIPE) as proc:
        tree_bin = proc.stdout.read()
        if proc.wait():
            raise RuntimeError('git ls-tree failed')
    tree = {}
    for entry in tree_bin.split(b'\0'):
        if entry == b'':
            continue
        meta, name = entry.split(b'\t', 1)
        _, obj_type, obj_hash = meta.split()
        subtree = read_tree(obj_hash) if obj_type == b'tree' else None
        tree[name] = (meta, subtree)
    return tree


def prune_tree(tree, exclusions, dir=''):
    exclude = []
    for name, (meta, subtree) in tree.items():
        full_name = os.path.join(dir, name.decode('utf-8'))
        for i, (glob, regex, matched) in enumerate(exclusions):
            if regex.fullmatch(full_name):
                if not matched:
                    # Not previously matched, so set the matched flag
                    exclusions[i] = (glob, regex, True)
                exclude.append(name)  # don't delete during iteration!
                break
        else:
            if subtree:
                prune_tree(subtree, exclusions, full_name)
    for name in exclude:
        del tree[name]


def write_tree(tree):
    # Update subtree hashes
    for name, (meta, subtree) in tree.items():
        if subtree:
            subtree_hash = write_tree(subtree)
            tree[name] = (meta[:-len(subtree_hash)] + subtree_hash, subtree)

    # Write this tree
    with subprocess.Popen(['git', 'mktree', '-z'], stdin=PIPE, stdout=PIPE) \
         as proc, \
         proc.stdin as in_pipe:
        for name, (meta, _) in tree.items():
            in_pipe.write(meta)
            in_pipe.write(b'\t')
            in_pipe.write(name)
            in_pipe.write(b'\0')
        in_pipe.close()
        tree_hash = proc.stdout.read().rstrip(b'\n')
        if len(tree_hash) < 40 or proc.wait():
            raise RuntimeError('git mktree failed')

    return tree_hash


def main(version):
    up_tag = 'upstream/' + version.replace('~', '_')
    real_up_tag = 'v' + VersionLinux('%s-0' % version).linux_upstream_full
    print('Using tag %s' % real_up_tag)

    # Verify real upstreaam tag
    gpg_wrapper = os.path.join(os.getcwd(),
                               "debian/bin/git-tag-gpg-wrapper")
    with subprocess.Popen(['git',
                           '-c', 'gpg.program=%s' % gpg_wrapper,
                           'tag', '-v', real_up_tag]) as proc:
        if proc.wait():
            raise RuntimeError("GPG tag verification failed")

    print("Excluding file glob patterns specified in debian/copyright")
    exclusions = []
    with open("debian/copyright") as f:
        copyright_header = deb822.Deb822(f)
        for glob in copyright_header.get("Files-Excluded", '').strip().split():
            exclusions.append((glob, glob_to_regex(glob), False))

    # Read the tree for the tag, apply exclusions, and write a new tree
    tree = read_tree(real_up_tag)
    prune_tree(tree, exclusions)
    tree_hash = write_tree(tree).decode('ascii')

    # Warn about unmatched patterns - it might mean the file(s) moved
    # and the pattern should be updated
    for glob, _, matched in exclusions:
        if not matched:
            warnings.warn("Exclusion glob pattern '%s' did not match anything"
                          % glob,
                          RuntimeWarning)

    # Write a commit
    parent_commit_hash = (
        subprocess.check_output(['git', 'rev-parse',
                                 '%s^{commit}' % real_up_tag],
                                encoding='ascii')
        .rstrip('\n'))
    with subprocess.Popen(
            ['git', 'commit-tree', '-p', parent_commit_hash,
             '-m',
             'Delete files for which the preferred form for modification is '
             'missing',
             tree_hash],
            stdout=PIPE) as proc:
        commit_hash = proc.stdout.read().rstrip(b'\n')
        if len(commit_hash) < 40 or proc.wait():
            raise RuntimeError('git commit-tree failed')
    commit_hash = commit_hash.decode('ascii')

    # Write a tag
    print('Creating tag %s' % up_tag)
    subprocess.check_call(['git', 'tag', '-s',
                           '-m',
                           'Linux %s with DFSG exclusions' % real_up_tag[1:],
                           up_tag, commit_hash])


if __name__ == '__main__':
    if len(sys.argv) == 2:
        main(sys.argv[1])
    else:
        sys.stderr.write('''\
Usage: %s VERSION
VERSION is the new upstream version (in Debian version format).
''' % sys.argv[0])
        sys.exit(2)
